由于 Anuke 学艺不精、大脑短路或思维混乱，Mindustry中经常会出现令人费解的运行机制，它们将使您的模组产生某些意料之外的行为，甚至崩溃游戏。本教程将探访一部分常见的原版游戏的暗坑，以帮助您处理模组运行问题。



## 山崩地裂型
本类型聚焦于常见使原版客户端崩溃的项目。

出于Anuke的过分自信，其代码缺乏防御性编程，很少对输入进行检查。当数据确实有误时，只会在运行期抛出**难以理解**的报错，如果没有经验，通常不可能发现其真正病根。

虽然针对实现编程十分糟糕，但Mindustry的工程实践甚至更加糟糕，有时不得不这样做。而后果就是，如果**改端**更改了实现方式，可能会导致代码出现问题，尽管目前仍未报道有 UI 方面以外改端导致的问题。

<font style="color:#DF2A3F;">在阅读以下内容之前，请先对</font>**<font style="color:#DF2A3F;">堆栈（Stacktrace</font>**<font style="color:#DF2A3F;">）及其阅读有基本了解，请先移步参阅</font>[深入理解Java异常堆栈：格式、处理与分类-CSDN博客](https://blog.csdn.net/u014365523/article/details/136382691)<font style="color:#DF2A3F;">。</font>

### Cannot read field "width或name" because "<某字段>" is null
### Cannot invoke "arc.func.Prov.get()" because "this.constructor" is null
### Cannot invoke "mindustry.graphics.g3d.HexMesher.skip(arc.math.geom.Vec3)" because "mesher" is null
## 通用性
本类型聚焦于一般性的报错，并给出解决思路

### 一般性的NullPointerException
**空指针错误（NullPointerException）**是一种运行时错误，原因通常是因为某个字段或方法的返回值是null，却又对其获取字段或执行方法，比如这样：

```java
Liquid test = null;
Log.info(test.name);
Log.info(test.toString());
```

这是比较直接的空指针错误，如果出现在你的代码里是很容易被发现的。而难于发现的是这种：

```java
Liquid test = null;
var ancientAltar = new GenericCrafter("ancient-altar") {{
    outputLiquids = LiquidStack.with(t,10f);
}}；
```

一般来说它会有这样的报错：

> java.lang.NullPointerException: Cannot read field "name" because "liq" is null
>
> 	at mindustry.world.Block.addLiquidBar(Block.java:562)
>
> 	at mindustry.world.blocks.production.GenericCrafter.setBars(GenericCrafter.java:88)
>
> 	at mindustry.world.Block.init(Block.java:1201)
>
> 	at mindustry.world.blocks.production.GenericCrafter.init(GenericCrafter.java:122)
>
> 	at mindustry.core.ContentLoader.initialize(ContentLoader.java:105)
>

这非常令人痛苦，这时如果你向他人求助，大概大家会给你这样的回答：

> “这不告诉你了吗 addliquidbar 自己写了什么心里没点数”
>
> “总之就是传参传着传着出现null了”
>

不过一切都好了，现在你可以自己看源代码来分析问题出在哪里了！

首先给出一个匹配公式：

:::color2
Cannot invoke "${方法签名或字段名称}" because "${空变量}" is null

Cannot invoke "${方法签名或字段名称}" because the return value of "${空返回方法}" is null

:::

对于上方来说，访问的字段名称是`name`，空变量为`liq`，最终执行位置是`mindustry.world.Block.addLiquidBar(Block.java:562)`（提示：安卓系统的行号可能不尽相同，精确度有时只能到方法），那么就请打开源代码，找到对应的代码并分析之。

```java
    public void addLiquidBar(Liquid liq){
        //562行之处
        addBar("liquid-" + liq.name, entity -> !liq.unlockedNow() ? null : new Bar(
            () -> liq.localizedName,
            liq::barColor,
            () -> entity.liquids.get(liq) / liquidCapacity
        ));
    }
```

这里就可以清晰地看到`liq`和`name`的身影了，不过在此仍然看不出来为什么liq是null，此时我们就需要顺个调用栈往回找了，即回到`mindustry.world.blocks.production.GenericCrafter.setBars(GenericCrafter.java:88)`：



```java
            //then display output buffer
            for(var stack : outputLiquids){
                addLiquidBar(stack.liquid);
            }
```

回找不能过度，就本例而言，这个位置就比较合适了，因为这样可以看到，传入的参数是`outputLiquids`中的`stack.liquid`，说明我们的`outputLiquids`引用了一个null的液体。

再之后的逻辑链条，就指向了为什么liquid是null，此问题多半出于加载时机把握不对。



还要注意，如果你已经回找到`mindustry.core.ContentLoader`了，那请再次回头吧，因为一旦进入`ContentLoader`，`EntityGroup`，`Logic`等大游戏逻辑类，就已经不是模组能踏足之地了。



## 缄口不言型
本类型聚焦于某些在原版代码中并没有明显提示，但对模组正常运行不可缺少的项目。

### 我的建筑在生存/战役/沙盒模式下不显示
该问题可能有许多原因：

+ 战役模式下，星球有自己的**隐藏物品（Hidden Item）**，在原版中通常是不属于本星的特效，如铍之于赛普罗。自定义游戏中，地图也有科技树设置。如果建筑的**物品需求**中含有为当前地图所隐藏的物品，则无法显示。
+ 你忘记给方块设置**物品需求**了。默认无物品需求的方块是**隐藏（hidden）**的，甚至不是**仅沙盒（Sandbox Only)**。如果是此问题，请参照原版设置`requirements`。

### 我的建筑无法拆除/设置的Bar没有生效/实体代码没有运行
该问题可能是出于您的方块被标记为不更新（update）的，这会导致您的方块不产生实体，从而不法进行交互。为确保是此问题，请做如下操作：

+ 在设置
+ 

