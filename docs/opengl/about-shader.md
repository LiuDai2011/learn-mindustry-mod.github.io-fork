# 着色器（Shader）

> 终于讲到着色器了！我们上一节只是解释了OpenGL绘图的流程与方式，但是其中最关键的着色器还未进行说明。经过本篇的讲解，我们就正式可以向屏幕上绘制图形了！

Arc GL强制使用OpenGL可编程管线，我们绘图时会需要向GL提供一些程序来告知GL如何去处理顶点以及为像素上色，而这些程序就被称为**着色器（Shader）**。

在Arc GL中，着色器程序又分两种：**顶点着色器（Vertex Shader）**与**片段着色器（Fragment Shader）**，而它们都被包装在了一个类型`arc.graphic.Shader`中，要创建一个着色器，只需要将着色器程序的内容作为参数传入到其构造函数即可：

```java
void sample(){
  String vertexShader = "...";
  String fragmentShader = "...";
  
  Fi vertShaderFi = new Fi("...");
  Fi fragShaderFi = new Fi("...");
  
  Shader shaderWithSource = new Shader(vertexShader, fragmentShader);
  Shader shaderWithFile = new Shader(vertShaderFi, fragShaderFi);
}
```

## glsl

在开始讲解着色器程序之前，我们需要先了解**GLSL**。GLSL是OpenGL着色语言（OpenGL Shading Language）的简称，编写着色器程序使用的就是GLSL编程语言。

> 这里有一些外部链接会讲解GLSL，尽管它们的平台可能有所差异，但是大多内容是互通的，而我们也会对GLSL的基本语法进行讲解：
> - **LearnOpenGL** https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/
> - **MDN** https://developer.mozilla.org/zh-CN/docs/Games/Techniques/3D_on_the_web/GLSL_Shaders
> - **知乎** https://zhuanlan.zhihu.com/p/349296191 
> - **简书** https://www.jianshu.com/p/5a2c4fff675e

GLSL是一种类似C的极简快速编程语言，它包含了宏，变量，函数，控制语句等基本语法，并添加了一些OpenGL的特性，例如向量，矩阵以及一些内置函数和内建变量。

## glsl数据类型

GLSL包含`float`、`int`、`bool`等基本数据类型，以及向量与矩阵类型，还包含了一类**采样器（Sampler）** 类型用于纹理采样，采样器在下节会详细介绍，本节我们先略过。

**向量类型**由`vec`开头，后随其向量维度：

| 类型      | 释义     |
|---------|--------|
| `vec2`  | 二维向量   |
| `vec3`  | 三维向量   |
| `vec4`  | 四维向量   |
| `ivec2` | 二维整数向量 |
| `ivec3` | 三维整数向量 |
| `ivec4` | 四维整数向量 |
| `bvec2` | 二维布尔向量 |
| `bvec3` | 三维布尔向量 |
| `bvec4` | 四维布尔向量 |

**矩阵类型**由`mat`开头，后随其矩阵的维度：

| 类型       | 释义     |
|----------|--------|
| `mat2`   | 二维矩阵   |
| `mat3`   | 三维矩阵   |
| `mat4`   | 四维矩阵   |
| `mat2x3` | 2行3列矩阵 |
| `mat2x4` | 2行4列矩阵 |
| `mat3x2` | 3行2列矩阵 |
| `mat3x4` | 3行4列矩阵 |
| `mat4x2` | 4行2列矩阵 |
| `mat4x3` | 4行3列矩阵 |

构造向量与矩阵有多种构造函数：

```glsl
vec3 a = vec3(1.0);           // (1.0, 1.0, 1.0)
vec3 b = vec3(1.0, 2.0, 3.0); // (1.0, 2.0, 3.0)
vec3 c = vec3(b);             // (1.0, 2.0, 3.0)
vec4 d = vec4(b, 1.0);        // (1.0, 2.0, 3.0, 1.0)

mat3 m = mat3(
  1.0, 2.0, 3.0, // | 1.0, 4.0, 7.0 |
  4.0, 5.0, 6.0, // | 2.0, 5.0, 8.0 |
  7.0, 8.0, 9.0  // | 3.0, 6.0, 9.0 |
);

mat3 n = mat3(a, b, c); 
// | 1.0, 1.0, 1.0 |
// | 1.0, 2.0, 2.0 |
// | 1.0, 3.0, 3.0 |

mat3 o = mat3(m);
// | 1.0, 4.0, 7.0 |
// | 2.0, 5.0, 8.0 |
// | 3.0, 6.0, 9.0 |

mat3 p = mat3(1.0);
// | 1.0, 1.0, 1.0 |
// | 1.0, 1.0, 1.0 |
// | 1.0, 1.0, 1.0 |
```

而当我们需要访问某个或某几个向量分量，亦或者我们要访问矩阵的某个或某列时，可以像对数组一样使用`[]`进行索引访问，亦或者对向量还可以通过`.x|y|z|w`或`.r|g|b|a`的组合进行多个分量的访问：

```glsl
vec4 a = vec4(1.0, 2.0, 3.0, 4.0);
float b = a[0]; // 1.0
float b = a[2]; // 3.0
float c = a.x;  // 1.0
float d = a.r;  // 1.0
vec2 e = a.xy;  // (1.0, 2.0)
vec2 f = a.gb;  // (2.0, 3.0)

mat3 m = mat3(
  1.0, 2.0, 3.0, // | 1.0, 4.0, 7.0 |
  4.0, 5.0, 6.0, // | 2.0, 5.0, 8.0 |
  7.0, 8.0, 9.0  // | 3.0, 6.0, 9.0 |
);
vec3 n = m[0];     // (1.0, 2.0, 3.0) - 第一列
vec3 o = m[2];     // (7.0, 8.0, 9.0) - 第三列
float p = m[0][1]; // 2.0 - 第一列第二行
float q = m[2].x;  // 7.0 - 第三列第一行
vec2 r = m[1].xy;  // (4.0, 5.0) - 第二列前两个元素
```

向量与向量，向量与矩阵和矩阵与矩阵均可以进行符合规则的数学运算，这部分属于线性代数的知识内容，如果对线性变换背后的数学原理感兴趣，可查阅相关资料，本篇我们只关注GLSL的语法。

> 向量与向量的`*`乘法与`/`除法是对分量逐个进行的，点乘法与叉乘法需要使用内置函数`dot(a, b)`与`cross(a, b)`。

运算范例：

```glsl
vec2 a = vec2(1.0, 2.0);
vec2 b = vec2(3.0, 4.0);
vec2 c = a + b; // c = vec2(4.0, 6.0)
vec2 c = a - b; // c = vec2(-2.0, -2.0)
vec2 d = a * b; // d = vec2(3.0, 8.0)
vec2 d = a / b; // d = vec2(1.0/3.0, 0.5)

mat2 m = mat2(
  2.0, 0.0,
  0.0, 2.0
);
mat2 n = mat2(
  0.0, 1.0,
  1.0, 0.0
);
mat2 o = m * n; 
// o = mat2(
//   0.0, 2.0,
//   2.0, 0.0
// )
vec2 t = a * m; // t = vec2(2.0, 4.0)
vec2 u = b * m; // u = vec2(6.0, 8.0)
```

我们编写glsl最重要的就是这些向量与矩阵的操作，而glsl的流程控制语句与C语言基本一致，包括`if`、`for`、`while`等，这里不再赘述。内建变量与内置函数在上方的外部链接中亦有详细介绍，后文中出现的一些内置函数与内建变量也会进行解释，这里不再多花篇幅。

## 顶点着色器（Vertex Shader）

顶点着色器负责在组装图元之前，处理输入的顶点数据，例如对绘制的顶点作变换，投影等操作。

## 片段着色器（Fragment Shader）


## 优化你的着色器！